import Command
import CoreML
import Testing
import TestingUtils

@testable import Embeddings

/*
 NOTE:
 The following test are testing the accuracy of the embeddings generated by the Swift models
 against the embeddings generated by the Python transformers library. They they are slow
 and require the [uv](https://github.com/astral-sh/uv) command line tool to be available.

 This suite can be run using the following command from the command line:

 ```
 UV_PATH=$(which uv) swift test --filter AccuracyTests
 ```

*/

func generateUsingTransformers(
    modelPath: String,
    text: String,
    isClip: Bool = false
) async throws -> [Float] {
    let scriptUrl = try #require(
        Bundle.module.path(forResource: "generate", ofType: "py", inDirectory: "Scripts"),
        "Script not found"
    )
    let uvPath = try #require(ProcessInfo.processInfo.environment["UV_PATH"], "UV_PATH not found")
    let arguments: [String] =
        if isClip {
            [uvPath, "run", scriptUrl, modelPath, text, "--isclip"]
        } else {
            [uvPath, "run", scriptUrl, modelPath, text]
        }
    let result =
        try await Command
        .run(arguments: arguments)
        .concatenatedString()
    return
        result
        .components(separatedBy: .newlines)
        .filter { !$0.isEmpty }
        .map { Float($0)! }
}

func modelPath(modelId: String, cacheDirectory: URL) -> String {
    cacheDirectory
        .appendingPathComponent("models")
        .appendingPathComponent(modelId)
        .path()
}

@Suite struct AccuracyTests {
    let cacheDirectory = FileManager.default.temporaryDirectory

    @Test(
        "Bert Accuracy",
        .enabled(if: ProcessInfo.processInfo.environment["UV_PATH"] != nil)
    )
    func bertAccuracy() async throws {
        let text = "Text to encode"
        let modelId = "google-bert/bert-base-uncased"
        let modelBundle = try await Bert.loadModelBundle(
            from: modelId,
            downloadBase: cacheDirectory,
            weightKeyTransform: Bert.googleWeightsKeyTransform
        )
        let encoded = try modelBundle.encode(text)
        let swiftData = await encoded.cast(to: Float.self).scalars(of: Float.self)
        let modelPath = modelPath(modelId: modelId, cacheDirectory: cacheDirectory)
        let pythonData = try await generateUsingTransformers(
            modelPath: modelPath,
            text: text
        )

        #expect(allClose(pythonData, swiftData, absoluteTolerance: 1e-5) == true)
    }

    @Test(
        "Clip Accuracy",
        .enabled(if: ProcessInfo.processInfo.environment["UV_PATH"] != nil)
    )
    func clipAccuracy() async throws {
        let text = "a photo of a dog"
        let modelId = "jkrukowski/clip-vit-base-patch32"
        let modelBundle = try await Clip.loadModelBundle(
            from: modelId,
            downloadBase: cacheDirectory
        )
        let tokens = try modelBundle.tokenizer.tokenizeText(text, maxLength: 77)
        let inputIds = MLTensor(shape: [1, tokens.count], scalars: tokens)
        let modelOutput = modelBundle.textModel(inputIds: inputIds)
        let swiftData =
            await modelOutput
            .poolerOutput
            .cast(to: Float.self)
            .scalars(of: Float.self)
        let modelPath = modelPath(modelId: modelId, cacheDirectory: cacheDirectory)
        let pythonData = try await generateUsingTransformers(
            modelPath: modelPath,
            text: text,
            isClip: true
        )

        #expect(allClose(pythonData, swiftData, absoluteTolerance: 1e-5) == true)
    }

    @Test(
        "XLM Roberta Accuracy",
        .enabled(if: ProcessInfo.processInfo.environment["UV_PATH"] != nil)
    )
    func xlmRobertaAccuracy() async throws {
        let text = "Text to encode"
        let modelId = "tomaarsen/xlm-roberta-base-multilingual-en-ar-fr-de-es-tr-it"
        let modelBundle = try await XLMRoberta.loadModelBundle(
            from: modelId,
            downloadBase: cacheDirectory
        )
        let encoded = try modelBundle.encode(text)
        let swiftData = await encoded.cast(to: Float.self).scalars(of: Float.self)
        let modelPath = modelPath(modelId: modelId, cacheDirectory: cacheDirectory)
        let pythonData = try await generateUsingTransformers(
            modelPath: modelPath,
            text: text
        )

        #expect(allClose(pythonData, swiftData, absoluteTolerance: 1e-5) == true)
    }
}
